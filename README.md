# [`vite-plugin-specifier`](https://www.npmjs.com/package/vite-plugin-specifier)

![CI](https://github.com/morganney/vite-plugin-specifier/actions/workflows/ci.yml/badge.svg)
[![NPM version](https://img.shields.io/npm/v/vite-plugin-specifier.svg)](https://www.npmjs.com/package/vite-plugin-specifier)

Vite plugin to update your ESM and CJS specifiers.

## Why would I need this?

Maybe you're running vite in [library mode](https://vitejs.dev/guide/build.html#library-mode), or using a plugin like [`vite-plugin-no-bundle`](https://github.com/ManBearTM/vite-plugin-no-bundle), and you want to be able to change the default specifier and file extensions generated by vite. This plugin allows you to do that using whatever `type` you want in your package.json.

## Example

Given an ESM-first (`"type": "module"`) project with this structure:

```
.
├── src/
│   ├── index.ts
│   └── file.ts
├── package.json
├── tsconfig.json
└── vite.config.ts
```

And a vite.config.ts defined like :

```ts
import { writeFile, rm } from 'node:fs/promises'

import { defineConfig } from 'vite'
import specifier from 'vite-plugin-specifier'

export default defineConfig(({
  build: {
    lib: {
      formats: ['cjs', 'es'],
      entry: ['src/index.ts', 'src/file.ts'],
    },
  },
  plugins: [
    specifier({
      // Changes all relative specifiers ending with .js to end with .mjs
      handler({ value }) {
        if (value.startsWith('./') || value.startsWith('../')) {
          return value.replace(/([^.]+)\.js$/, '$1.mjs')
        }
      },
      /**
       * Rewrites emitted files with updated specifiers and an .mjs file extension
       * before removing the file with the old code and file extension.
       * 
       * `records` is a Record<string, string> of { [filename: string]: code }
       */
      async writer(records) {
        const files = Object.keys(records)

        for (const filename of files) {
          if (typeof records[filename] === 'string' && filename.endsWith('.js')) {
            await writeFile(filename.replace(/\.js$/, '.mjs'), records[filename])
            await rm(filename, { force: true })
          }
        }
      },
    }),
  ],
}))
```

Running the vite build would produce the following:

```
.
├── dist/
│   ├── index.cjs
│   ├── index.mjs
│   ├── file.cjs
│   └── file.mjs
├── src/
│   ├── index.ts
│   └── file.ts
├── package.json
├── tsconfig.json
└── vite.config.ts
```

You can do the same for a CJS-first project, or change specifiers and file extensions in any useful way.

## Options

This plugin accepts the following options. There is no default `writer` unless you specify `true` in which case, the writer rewrites the updated code back to the original filename. The default value for `hook` is `writeBundle`.

```ts
interface SpecifierOptions {
  handler: Callback | RegexMap
  /**
   * If `true`, default writer will be used which rewrites the updated
   * code back to the original filename in `outDir`.
   * 
   * Otherwise, a callback will be passed a Record<string, string> of
   * { [filename: string]: updatedCode }.
   */
  writer?: boolean | ((records: Record<string, string>) => Promise<void>)
  hook?: 'writeBundle' | 'transform'
}
```

The other types are defined as such:

```ts
interface Spec {
  type: 'StringLiteral' | 'TemplateLiteral' | 'BinaryExpression' | 'NewExpression'
  start: number
  end: number
  value: string
  loc: SourceLocation
}
interface RegexMap {
  [regex: string]: string
}
type Callback = (spec: Spec) => string
interface UpdateError {
  error: boolean
  msg: string
  filename?: string
  syntaxError?: {
    code: string
    reasonCode: string
    pos: number
    loc: Position
  }
}
```
